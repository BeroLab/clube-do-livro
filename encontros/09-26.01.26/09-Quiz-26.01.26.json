{
  "title": "Quiz: O Programador Pragmático – Capítulo 2 (Parte 1)",
  "description": "Teste seus conhecimentos sobre os conceitos de DRY, Ortogonalidade, Reversibilidade e Projéteis Luminosos do livro O Programador Pragmático.",
  "questions": [
    {
      "id": 1,
      "question": "Qual é o princípio fundamental do DRY (Don't Repeat Yourself)?",
      "options": [
        { "text": "Escrever o código o mais rápido possível.", "justification": "DRY não é sobre velocidade, mas sobre manutenção e evitar duplicação de conhecimento." },
        { "text": "Cada pedaço de conhecimento deve ter uma representação única, inequívoca e autoritária.", "justification": "Correto! Isso evita inconsistências e facilita a manutenção, pois a mudança é feita em um só lugar." },
        { "text": "Evitar usar a mesma variável em funções diferentes.", "justification": "Isso é escopo de variável, não o princípio DRY em sua essência." },
        { "text": "Duplicar código para desacoplar módulos.", "justification": "Pelo contrário, o DRY busca reduzir a duplicação, não incentivá-la." }
      ],
      "correctAnswer": "Cada pedaço de conhecimento deve ter uma representação única, inequívoca e autoritária."
    },
    {
      "id": 2,
      "question": "O que significa um sistema ser 'ortogonal'?",
      "options": [
        { "text": "Que ele foi escrito em uma linguagem de baixo nível.", "justification": "A ortogonalidade é um conceito de design, não está ligada à linguagem." },
        { "text": "Que os componentes do sistema são altamente dependentes uns dos outros.", "justification": "Incorreto. Ortogonalidade significa independência e desacoplamento entre os componentes." },
        { "text": "Que mudanças em um componente têm pouco ou nenhum efeito sobre os outros.", "justification": "Correto! Isso isola o impacto das mudanças, tornando o sistema mais robusto e fácil de testar." },
        { "text": "Que o sistema é geometricamente perfeito.", "justification": "É uma analogia com a geometria, mas o significado é sobre independência de componentes." }
      ],
      "correctAnswer": "Que mudanças em um componente têm pouco ou nenhum efeito sobre os outros."
    },
    {
      "id": 3,
      "question": "Qual a principal diferença entre 'Tracer Bullets' (Projéteis Luminosos) e 'Protótipos'?",
      "options": [
        { "text": "Protótipos são feitos para serem descartados; Projéteis Luminosos são o esqueleto que evoluirá para o produto final.", "justification": "Correto! Protótipos são para aprender e depois jogar fora. Projéteis luminosos são uma primeira versão funcional, ainda que magra, do sistema." },
        { "text": "Projéteis Luminosos são mais complexos que protótipos.", "justification": "Não necessariamente. A diferença está no propósito (descartável vs. incremental), não na complexidade." },
        { "text": "Não há diferença, são apenas nomes diferentes para a mesma coisa.", "justification": "Falso. Eles servem a propósitos muito distintos no processo de desenvolvimento." },
        { "text": "Protótipos testam a arquitetura, enquanto Projéteis Luminosos testam a interface do usuário.", "justification": "Ambos podem ser usados para testar diferentes aspectos, mas a diferença crucial é o destino do código." }
      ],
      "correctAnswer": "Protótipos são feitos para serem descartados; Projéteis Luminosos são o esqueleto que evoluirá para o produto final."
    },
    {
      "id": 4,
      "question": "O princípio da 'Reversibilidade' sugere que...",
      "options": [
        { "text": "Você deve ser capaz de reverter qualquer commit no controle de versão.", "justification": "Embora útil, o princípio se refere a decisões de arquitetura e design, não apenas ao controle de versão." },
        { "text": "As decisões de design e arquitetura não devem ser gravadas em pedra, permitindo mudanças futuras.", "justification": "Correto! O objetivo é minimizar o custo de mudanças futuras, evitando 'becos sem saída' tecnológicos ou arquiteturais." },
        { "text": "O software deve funcionar da mesma forma de trás para frente.", "justification": "Isso não faz sentido no contexto de engenharia de software." },
        { "text": "Toda função deve ter uma função inversa correspondente.", "justification": "Isso se aplica à matemática, mas não é o significado de Reversibilidade no livro." }
      ],
      "correctAnswer": "As decisões de design e arquitetura não devem ser gravadas em pedra, permitindo mudanças futuras."
    },
    {
      "id": 5,
      "question": "Qual das seguintes opções é uma consequência direta da falta de ortogonalidade em um sistema?",
      "options": [
        { "text": "O código se torna mais rápido e eficiente.", "justification": "Falso. A falta de ortogonalidade geralmente leva a um código mais complexo e lento." },
        { "text": "Uma pequena mudança em um módulo causa um efeito cascata de mudanças em outros módulos.", "justification": "Correto! Isso é um sintoma clássico de alta acoplamento (falta de ortogonalidade), tornando o sistema frágil." },
        { "text": "O sistema se torna mais fácil de testar.", "justification": "O oposto é verdadeiro. Testar componentes independentes é muito mais fácil." },
        { "text": "A equipe de desenvolvimento ganha mais produtividade.", "justification": "Incorreto. A produtividade diminui porque os desenvolvedores precisam se preocupar com efeitos colaterais inesperados." }
      ],
      "correctAnswer": "Uma pequena mudança em um módulo causa um efeito cascata de mudanças em outros módulos."
    },
    {
      "id": 6,
      "question": "O livro descreve vários tipos de duplicação. Qual dos itens abaixo NÃO é um deles?",
      "options": [
        { "text": "Duplicação imposta.", "justification": "Incorreto. O livro menciona a duplicação imposta, que ocorre quando o ambiente ou framework parece não dar outra escolha." },
        { "text": "Duplicação inadvertida.", "justification": "Incorreto. A duplicação inadvertida acontece quando os desenvolvedores não percebem que estão duplicando informação." },
        { "text": "Duplicação intencional.", "justification": "Correto! Embora a 'duplicação impaciente' seja intencional, o livro não usa o termo 'duplicação intencional' como uma categoria." },
        { "text": "Duplicação impaciente.", "justification": "Incorreto. A duplicação impaciente acontece por preguiça, pois parece mais fácil no curto prazo." }
      ],
      "correctAnswer": "Duplicação intencional."
    },
    {
      "id": 7,
      "question": "Qual é o principal objetivo da abordagem de 'Projéteis Luminosos'?",
      "options": [
        { "text": "Entregar o produto finalizado na primeira tentativa.", "justification": "Não, o objetivo não é entregar o produto completo, mas sim um esqueleto funcional." },
        { "text": "Obter feedback rápido sobre a arquitetura e a integração de todas as partes do sistema.", "justification": "Correto! Ele serve para provar que a abordagem de ponta a ponta funciona antes de construir toda a funcionalidade." },
        { "text": "Criar uma documentação detalhada antes de escrever o código.", "justification": "A abordagem é sobre código funcional, não sobre documentação prévia." },
        { "text": "Testar apenas a interface do usuário com dados falsos.", "justification": "Ao contrário, um projétil luminoso deve ser funcional de ponta a ponta, usando a arquitetura real." }
      ],
      "correctAnswer": "Obter feedback rápido sobre a arquitetura e a integração de todas as partes do sistema."
    },
    {
      "id": 8,
      "question": "Aplicar o princípio da Reversibilidade ao escolher um banco de dados significaria...",
      "options": [
        { "text": "Usar o banco de dados mais popular do mercado, pois ele nunca será descontinuado.", "justification": "Popularidade não garante adequação futura. Isso pode levar ao aprisionamento tecnológico (vendor lock-in)." },
        { "text": "Escrever queries SQL nativas e otimizadas para o banco de dados escolhido em todo o código.", "justification": "Isso é o oposto da reversibilidade, pois dificulta enormemente a troca do banco de dados no futuro." },
        { "text": "Isolar o acesso ao banco de dados por trás de uma camada de abstração (como um Repositório ou ORM).", "justification": "Correto! Se a necessidade de trocar de banco de dados surgir, a mudança fica contida nessa camada de abstração." },
        { "text": "Escolher um banco de dados e nunca mais considerar trocá-lo.", "justification": "Isso é uma decisão inflexível, o que o princípio da Reversibilidade visa evitar." }
      ],
      "correctAnswer": "Isolar o acesso ao banco de dados por trás de uma camada de abstração (como um Repositório ou ORM)."
    },
    {
      "id": 9,
      "question": "Se a mesma regra de negócio precisa ser implementada no back-end (em Java) e no front-end (em JavaScript), qual seria a melhor abordagem DRY?",
      "options": [
        { "text": "Escrever a regra cuidadosamente em ambos os lugares e garantir que as equipes estejam sincronizadas.", "justification": "Isso é um exemplo de 'duplicação entre desenvolvedores' e é propenso a erros." },
        { "text": "Gerar o código de um a partir do outro ou usar uma fonte de definição comum (como um arquivo de configuração).", "justification": "Correto! Ter uma única fonte de verdade da qual o código é gerado ou lido é uma excelente estratégia DRY." },
        { "text": "Implementar a regra apenas no back-end e confiar que o front-end sempre fará a validação lá.", "justification": "Isso pode ser uma solução, mas nem sempre é viável para feedback imediato ao usuário. A melhor solução é ter uma fonte única." },
        { "text": "Deixar que a duplicação ocorra, pois são linguagens diferentes.", "justification": "O princípio DRY se aplica ao conhecimento, não apenas ao código. A linguagem não é uma desculpa para duplicar a lógica de negócio." }
      ],
      "correctAnswer": "Gerar o código de um a partir do outro ou usar uma fonte de definição comum (como um arquivo de configuração)."
    },
    {
      "id": 10,
      "question": "Qual o principal benefício de um sistema ortogonal em relação aos testes?",
      "options": [
        { "text": "A ortogonalidade elimina a necessidade de testes.", "justification": "Falso. Nenhum princípio de design elimina a necessidade de testes." },
        { "text": "É possível testar cada componente de forma isolada, sem a necessidade de iniciar o sistema inteiro.", "justification": "Correto! O desacoplamento permite testes de unidade mais focados e eficazes, simplificando a detecção de falhas." },
        { "text": "Os testes se tornam mais lentos, pois há mais componentes.", "justification": "Pelo contrário, testes focados em unidades isoladas tendem a ser muito mais rápidos." },
        { "text": "Apenas testes de integração são possíveis.", "justification": "A ortogonalidade facilita enormemente os testes de unidade, que são um pilar dos testes de software modernos." }
      ],
      "correctAnswer": "É possível testar cada componente de forma isolada, sem a necessidade de iniciar o sistema inteiro."
    }
  ]
}
